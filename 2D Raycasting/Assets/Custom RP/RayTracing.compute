// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> _SkyBoxTexture;
SamplerState sampler_SkyBoxTexture;

float2 _PixelOffset;
float4 _DirLight;
float3 _SkyColor;



static const int MAX_BOUNCES = 8;
static const float PI = 3.14159f;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

struct Sphere
{
	float3 position;
	float radius;
	float3 albedo;
	float3 specular;
};
StructuredBuffer<Sphere> _Spheres;

struct Ray
{
	float3 origin;
	float3 direction;
	float3 energy;
};
struct RayHit
{
	float3 position;
	float distance;
	float3 normal;
	float3 albedo;
	float3 specular;
};
RayHit CreateRay()
{
	RayHit hit;
	hit.position = float3(0, 0, 0);
	hit.distance = 1.#INF;
	hit.normal = float3(0, 0, 0);
	return hit;
}


Ray CreateRay(float3 origin, float3 direction)
{
	Ray ray;
	ray.origin = origin;
	ray.direction = direction;
	ray.energy = float3(1.0f, 1.0f, 1.0f);
	return ray;
}
Ray CreateCameraRay(float2 uv)
{
	// Transform the camera origin to world space
	float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

	// Invert the perspective projection of the view-space position
	float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
	// Transform the direction from camera to world space and normalize
	direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
	direction = normalize(direction);
	return CreateRay(origin, direction);

}
//sphere is a float4( position, radius) => xyz values are pos, w is the radius
void IntersectSphere(Ray ray, inout RayHit hit, Sphere sphere)
{
	//direction vector
	float3 d = ray.origin - sphere.position.xyz;
	float p1 = -dot(ray.direction, d);
	float p2sqrt = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;
	//no intersection
	if (p2sqrt < 0) return;
	float p2 = sqrt(p2sqrt);
	//ray has up to 2 intersection points with a sphere, pick valid intersection point
	float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
	//check if t is valid & smaller than previous hit
	if (t > 0 && t < hit.distance)
	{
		hit.distance = t;
		hit.position = ray.origin + ray.direction * t;
		hit.normal = normalize(hit.position - sphere.position);
		hit.albedo = sphere.albedo;
		hit.specular = sphere.specular;
	}
}
void IntersectGroundPlane(Ray ray, inout RayHit hit)
{
	float t = -ray.origin.y / ray.direction.y;
	if (t > 0 && t < hit.distance)
	{
		hit.distance = t;
		hit.position = ray.origin + t * ray.direction;
		hit.normal = float3(0, 1, 0);
		hit.albedo = float3(1, 1, 1);
		hit.specular = float3(0, 0, 0);
	}
}
RayHit Trace(Ray ray)
{
	RayHit hit = CreateRay();
	//intersect with ground plane
	IntersectGroundPlane(ray, hit);

	//trace spheres

	uint sphereCount, stride;
	_Spheres.GetDimensions(sphereCount, stride);
	for (uint i = 0; i < sphereCount; i++)
	{
		IntersectSphere(ray, hit, _Spheres[i]);
	}

	//for (int i = 0; i < 6; i++)
	//{
	//	for (int j = 0; j < 6; j++)
	//	{
	//		for (int z = 0; z < 1; z++)
	//		{
	//			IntersectSphere(ray, hit, float4(2.5f * i + z, 1 + z * 2.5f, 2.5f * j, 1.0f));
	//		}
	//	}
	//}
	//	IntersectSphere(ray, hit, float4(0, 3.0f, 0, 1.0f));
	return hit;
}

float3 Shade(inout Ray ray, RayHit hit)
{
	if (hit.distance < 1.#INF)
	{
		//trace shadow
		bool shadow = false;
		Ray shadowRay = CreateRay(hit.position + hit.normal * 0.001f, -1 * _DirLight.xyz);
		RayHit shadowHit = Trace(shadowRay);
		if (shadowHit.distance != 1.#INF)
			return float3(0.0f, 0.0f, 0.0f);


		//brdf, this defines how much light for each color channel is reflected do not go over 1 
	//	hit.specular;
	//	float3 spec = float3(0.6f, 0.6f, 0.6f);
		//slight offset to make sure the reflected ray does not intersect with collision object itself
		ray.origin = hit.position + hit.normal * 0.001f;
		//reflect direction
		ray.direction = reflect(ray.direction, hit.normal);
		ray.energy *= hit.specular;



		float3 albedo = hit.albedo;

		return saturate(dot(hit.normal, _DirLight.xyz) * -1) * _DirLight.w * albedo;

	}
	else
	{
		//else hit with skybox, skybox does not reflect => energy=0
		ray.energy = 0.0f;
		return _SkyColor;
	}
}



[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	uint width, height;
	Result.GetDimensions(width, height);

	float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);
	Ray ray = CreateCameraRay(uv);

	/*RayHit hit = Trace(ray);
	float3 result = Shade(ray, hit);*/

	float3 result = float3(0, 0, 0);
	for (int i = 0; i < MAX_BOUNCES; i++)
	{
		RayHit hit = Trace(ray);
		result += ray.energy * Shade(ray, hit);
		if (!any(ray.energy))
			break;
	}

	Result[id.xy] = float4(result, 1);

}
